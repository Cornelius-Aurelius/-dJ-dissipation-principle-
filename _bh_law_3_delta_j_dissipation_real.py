# -*- coding: utf-8 -*-
"""-BH_LAW_3_DELTA_J_DISSIPATION_REAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wox-CQr_gFoVJ04shZ2MPNICvGhSlDKg
"""

# =====================================================================
#  BH_LAW_3 — REAL MODE: δJ Dissipation Verification
# =====================================================================

import numpy as np
import matplotlib.pyplot as plt

# ----------------------------------------------------------
# Gradient (REAL)
# ----------------------------------------------------------

def grad(A):
    Ax = np.roll(A, -1, axis=0) - A
    Ay = np.roll(A, -1, axis=1) - A
    return Ax, Ay

# ----------------------------------------------------------
# Laplacian (REAL)
# ----------------------------------------------------------

def laplacian(A):
    return (
        np.roll(A,1,0) + np.roll(A,-1,0) +
        np.roll(A,1,1) + np.roll(A,-1,1)
        - 4*A
    )

# ----------------------------------------------------------
# δJ functional = ||∇A|| + ||∇²A||
# ----------------------------------------------------------

def delta_J(A):
    Ax, Ay = grad(A)
    lapA = laplacian(A)
    term1 = np.mean(np.sqrt(Ax**2 + Ay**2))
    term2 = np.mean(np.abs(lapA))
    return term1 + term2

# ----------------------------------------------------------
# REAL PDE evolution
# ----------------------------------------------------------

def evolve_delta_J(A0, steps=150, alpha=0.10):
    A = A0.copy()
    J_vals = []

    for _ in range(steps):
        J_vals.append(delta_J(A))
        A = A + alpha * laplacian(A)
    return np.array(J_vals)

# ----------------------------------------------------------
# Initial field
# ----------------------------------------------------------

N = 128
x = np.linspace(0, 2*np.pi, N)
y = np.linspace(0, 2*np.pi, N)
X, Y = np.meshgrid(x, y)

A0 = np.sin(3*X) * np.cos(2*Y) + 0.3*np.random.randn(N, N)

# ----------------------------------------------------------
# Run REAL δJ dissipation test
# ----------------------------------------------------------

J_vals = evolve_delta_J(A0)

# ----------------------------------------------------------
# Plot REAL δJ decay
# ----------------------------------------------------------

plt.figure(figsize=(12,4))
plt.plot(J_vals)
plt.title("BH_LAW_3 — REAL δJ Dissipation")
plt.xlabel("Iteration")
plt.ylabel("δJ")
plt.grid(True)
plt.show()

# ----------------------------------------------------------
# REAL verdict
# ----------------------------------------------------------

def verdict(vals):
    monotonic = np.all(np.diff(vals) <= 1e-6)
    strong = vals[-1] < 0.05 * vals[0]
    return "PASS" if (monotonic and strong) else "FAIL"

print("VERIFICATION_RESULT:", verdict(J_vals))

